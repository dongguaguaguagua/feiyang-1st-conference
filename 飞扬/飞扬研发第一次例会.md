[toc]

## Part1. Python 光速入门

> 写在前面：本教程只是带你过一遍 python 的基础语法，最最浅显的那种，目的就是为了让每个读者看完以后，都有能力**安装并使用第三方模块**，从而快速获得写 python 的快感，大大降低学习曲线。
> 
> 总言之，我的建议是「先快速上手，找个好玩的东西做，然后再考虑往深里学」。比如我这篇教程好多都是照搬[廖雪峰的python教程](https://www.liaoxuefeng.com/wiki/1016959663602400)的内容，讲的真的很好啊，但是这一系列文章没有几个礼拜你啃不完啊，等你啃完了，学习的热情早就没了。
> 
> 当然，大佬另说嗷，不在本文的考虑范围内。

### 0. 安装 python 与开发环境推荐

#### python 的安装非常简单。

1. 在[官网](https://www.python.org/)下载 python 安装包，安装时一定记得勾选**Add Python 3.8 to PATH**
2. ![fefd7e5318b8c576625f4d980d90a3df.png](/image_resources/fefd7e5318b8c576625f4d980d90a3df.png)
3. 菜单栏里打开命令提示符，输入 python 后回车，如果出现 >>> ，即所谓的「python 解释器」或者「python 交互环境」，则可视为安装成功。
4. ![537d3b776437243645d2cf7c666bc118.png](/image_resources/537d3b776437243645d2cf7c666bc118.png)

输入 python 后发生了什么？首先系统会在你的 path 中（也就是环境变量里，环境变量是由一堆文件夹组成的，都可以在设置里设置）寻找 python 可执行程序。然后在命令提示符中运行它，看到 >>> 后说明你已经进入了 python 解释器，也就是 python 交互式环境。

这里提一嘴 anaconda：除非你有同时安装多个 python 版本的需求（一般来说是不需要的），非常不建议使用 anaconda，因为下载、安装、使用等等对新手太不友好了，非常容易劝退，真不如直接在官网下载 python 安装包并安装。

#### 开发环境配置

我们推荐微软出品的[Visual Studio Code](https://code.visualstudio.com/)，它不是那个大块头的 Visual Studio，它是一个精简版的迷你 Visual Studio，并且，Visual Studio Code 可以跨！平！台！Windows、Mac 和 Linux 通用。

也可以用高颜值的[sublime text4](http://www.sublimetext.com/)。同样跨平台，比 vscode 启动更快，缺点是不开源。

请注意，不要用 Word 和 Windows 自带的记事本。Word 保存的不是纯文本文件，而记事本会自作聪明地在文件开始的地方加上几个特殊字符（UTF-8 BOM），结果会导致程序运行出现莫名其妙的错误。

安装完编辑器后，新建后缀名为`.py`的文本文件（大部分编辑器根据后缀名识别文件执行方式，比如`.c`文件编辑器会选择编译运行），比如 helloword.py，文件名可以随便取。里面就可以编辑 python 语句了，比如我写一句

```python
print(100+200)
```

然后在编辑器里直接运行。可以看到结果为 300。如果看不到结果，反而报什么 python 不是可执行程序的话，说明你上一步「add python to path」没有勾选。

### 1. Python 是一种什么语言？

首先，我们普及一下编程语言的基础知识。用任何编程语言来开发程序，都是为了让计算机干活，比如下载一个 MP3，编写一个文档等等，而计算机干活的 CPU 只认识机器指令，所以，尽管不同的编程语言差异极大，最后都得“翻译”成 CPU 可以执行的机器指令。而不同的编程语言，干同一个活，编写的代码量，差距也很大。

比如，完成同一个任务，C 语言要写 1000 行代码，Java 只需要写 100 行，而 Python 可能只要 20 行。

这是 C 语言的 hello world：

```c
#include <stdio.h>
int main()
{
   printf("Hello World!");
   return 0;
}
```

Java：

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```

python：

```python
print("Hello World!")
```

所以 Python 是一种相当高级的语言。

你也许会问，代码少还不好？代码少的代价是运行速度慢，C 程序运行 1 秒钟，Java 程序可能需要 2 秒，而 Python 程序可能就需要 10 秒。

这里说明一点，你可以在命令行里看到，python 解释器中的 python 语句是一行一行的：

![0e884a826c2cffaf26775d1195de9ec2.png](/image_resources/0e884a826c2cffaf26775d1195de9ec2.png)

```python
>>> print("hello world!")
hello world!
>>> print(100+200)
300
>>>
```

同样的，你的`.py`文件中的代码在执行时会一行一行地翻译成 CPU 能理解的机器码，这个翻译过程非常耗时，所以很慢。而 C 程序是运行前直接编译成 CPU 能执行的机器码，所以非常快。

但是，看在开发 python 如此舒适的分上，运行慢一点完全可以接受啊。

![8a571075ea57f74a1299d8ee09171f8a.png](/image_resources/8a571075ea57f74a1299d8ee09171f8a.png)

此外，运行`.py`文件和在 Python 交互式环境下直接运行 Python 代码一点点不同。Python 交互式环境会把每一行 Python 代码的结果自动打印出来，但是，直接运行 Python 代码却不会。

PS: 我都是把 python 解释器当简易计算器用的，非常好用，毕竟支持所有常见的表达式，演示一下：

```python
>>> a = -8080
>>> b = 1.234e9
>>> b
1234000000.0
>>> 2**100 # 2的100次方
1267650600228229401496703205376
>>> b**0.5 # 对b开根
35128.33614050059
>>> a + b
1233991920.0
>>> b/a
-152722.77227722772
>>>
```

### 2. 基本语法详解

> “#”是注释的意思，它后面的文字会被 Python 忽略。

#### 2.0 变量

我们可以把数据存到变量里。使用方法如下：

```python
>>> a = 100
>>> b = 3.1415926
>>> c = "一串字符串，里面可以是任意文本"
>>> a + b # 103.1415926
>>> a = 10 # a的值可以改变
>>> a + b # 13.1415926
```

> **所有名称（变量名称，包括后面要学的函数名称、类名称）都是完全自定义的，你想取什么名字就可以取什么名字。**

c 是一串字符串。python 里，用“引号”扩起来的文字**被标记为**字符串，字符串顾名思义，就是把字符串起来。`c = "I'm OK"`，那 c 里面包含的字符就是`I`、`'`、`m`、空格、`O`、`K`这 6 个字符。

```python
>>> b = 3.1415926 # b是小数（浮点数）
>>> c = "3.1415926" # c和b不一样，
```

那么如果我想让 c 的内容是`"hello"`怎么办？注意到 c 头尾两个字符是 python 默认「定义字符串」用的双引号，难道这样写吗？

```python
>>> c = ""hello""
  File "<stdin>", line 1
    c = ""hello""
          ^^^^^
SyntaxError: invalid syntax
```

看代码颜色就一目了然：字符串内部的`"`和 python 语法冲突了，那怎么办呢？

天才的程序员们想到了这两个办法：

1. 包裹字符串的双引号可以换成单引号，这样就没有歧义了：`c = '"hello"'`
2. 使用转义字符 `\`

```python
>>> c = "\"hello\""
>>> c
'"hello"'
```

我当时学到转义字符的时候也是懵逼的，其实可以这样理解：python 挑选了很不常用的，但是可以在键盘上打出来的字符：`\`，作为「转义字符」，即如果在字符串里看到了这个，就不能当成正常的字符 `\` 处理了，而是看成一个标记——**代表`\`后面的那个字符需要转义**——就是告诉计算机，`\`后面那个字符是特殊的。

解释一下`c = "\"hello\""`：引号里扩起来的两个`\`后面都是`"`，说明什么？说明`"`不应该正常的把它视为字符串的终止符号，而是字符串的一部分。于是`\"`才算做一个字符。那问题来了，虽然`\`不常用，但是还是在某些系统的路径中频繁出现，如果我想要在字符串中加上`\`怎么办？不是说计算机不会把`\`看作正常字符吗？

其实，我们只需要用`\`转义一下`\`就行了，听起来有点绕，就是用转义字符标记`\`为特殊的，计算机就不会把`\`当成转义字符来看待，而是正常字符。有负负得正的味道了。于是：

```python
>>> print("\\")
\
```

这里我给出一个常用转义字符对照表：

| 转义字符 | 意义                   | ASCII |
| -------- | ---------------------- | ----- |
| `\0`     | 空字符(NUL)            | 0     |
| `\t`     | 制表符                 | 9     |
| `\n`     | 换行符                 | 10    |
| `\"`     | 代表一个双引号字符     | 34    |
| `\'`     | 代表一个单引号         | 39    |
| `\\`     | 代表一个反斜线字符'\\' | 92    |

我们可以使用`type()`来查看变量的数据类型：

```python
>>> type(a)  # 整数
<class 'int'>
>>> type(b) # 浮点数
<class 'float'>
>>> type(c) # 字符串
<class 'str'>
>>> type(True) # 布尔值
<class 'bool'>
```

可以看到，还一种数据类型叫做「布尔值」，布尔值是音译的英语“bool”，其实比整数啥的更简单，因为布尔值只有两个值： True 和 False。

**！一定要注意 True 和 False 的首字母大写！**

布尔值的运算和数字稍微有点不同，但是基本上高中数学老师都教过：

```python
>>> True
True
>>> False
False
>>> 3 > 2
True
>>> 3 > 5
False
>>> True and True # 与运算
True
>>> True and False
False
>>> False and False
False
>>> 5 > 3 and 3 > 1
True
>>> True or True # 或运算
True
>>> True or False
True
>>> False or False
False
>>> 5 > 3 or 1 > 3
True
>>> not True # 非运算
False
>>> not False
True
>>> not 1 > 2
True
```

布尔值经常会用到条件判断语句中，后面会提到的。

**请不要把赋值语句的等号等同于数学的等号**。比如下面的代码：

```python
x = 10
x = x + 2
```

如果从数学上理解`x = x + 2`那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式`x + 2`，得到结果 12，再赋给变量 x。由于 x 之前的值是 10，重新赋值后，x 的值变成 12。

其实 python 提供的「数据类型」不止小数、整数、字符串、布尔值，还有下面会讲的「数组」「元组」「字典」都是 python 自带的数据类型，其实你完全可以自定义一个新的数据类型，我们叫做定义「类」。

#### 2.1 输入输出

python 中负责输入输出的函数是`print`。注意到我用了一个还没讲到的概念：函数。

函数，就像数学里面的函数一样，我扔给它好几个输入，它就用我给的输入做一些事情。

学编程语言其实应该试着去理解。

比如学 C 语言，不能死记硬背`#include <stdio.h>`，应该理解成「把'stdio.h'里面所有的东西都给我拿来（包括进来）」为什么是`stdio.h`？std -> standard; io -> input output。连起来就是「标准输入输出文件」。干什么用的？原来你的 hello world 程序里面有一步是「在命令行黑框框里打印出一行 hello world」，必须要用到`printf`函数啊。不把`stdio`文件“拿过来”，哪来的`printf`函数呢？所以，其实你只要不输出，把这行引用删掉也无所谓。

再回到 python，python 给我们内置了一些常用函数，不用像 C 一样 include（当然有些不常用的函数还是需要从别的地方拿过来的）。print 的意思就是打印嘛，打印到哪？打印到控制台。我可以传给 print 任何东西（记得用逗号隔开，就和数学里的`f(x, y, z)`一样），它就负责把它获得的所有输入展现在命令行黑框框里：

```python
print("100+200 =", 100+200)
# 100+200 = 300
```

同样的，python 中的输入函数是`input()`，不用给它传参数，当然也可以传一个“输入提示”：

```python
name = input('please enter your name: ')
print('hello,', name)
```

```bash
~/myWorkspace> python hello.py
please enter your name: Michael
hello, Michael
```

#### 2.2 List（数组）、Tuple（元组）与 Dict（字典）

python 中除了有数字、字符串这些数据类型外，还有「数组」类型。顾名思义，你可以把“一组数字”存到一个变量中。具体如下：

```python
>>> numbers = [2, 4, 7, 3, 9, 10]
```

`len()`函数可以获得 list 元素的个数：

```python
>>> len(numbers)
6
```

除了数字意外，「数组还可以存放任意数据类型」，比如字符串：

```python
>>> classmates = ['Michael', 'Bob', 'Tracy']
>>> classmates
['Michael', 'Bob', 'Tracy']
```

用「索引」来访问 list 中每一个位置的元素，记得索引是从 0 开始的：

```python
>>> classmates[0]
'Michael'
>>> classmates[1]
'Bob'
>>> classmates[2]
'Tracy'
>>> classmates[3]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

当索引超出了范围时，Python 会报一个 IndexError 错误，所以，要确保索引不要越界，记得最后一个元素的索引是`len(classmates) - 1`。

如果要取最后一个元素，除了计算索引位置外，还可以用-1 做索引，直接获取最后一个元素：

```python
>>> classmates[-1]
'Tracy'
```

list 是一个可变的有序表，所以，可以往 list 中追加元素到末尾：

```python
>>> classmates.append('Adam')
>>> classmates
['Michael', 'Bob', 'Tracy', 'Adam']
```

也可以把元素插入到指定的位置，比如索引号为 1 的位置：

```python
>>> classmates.insert(1, 'Jack')
>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']
```

要删除 list 末尾的元素，请用`pop()`：

```python
>>> classmates.pop()
'Adam'
>>> classmates
['Michael', 'Jack', 'Bob', 'Tracy']
```

要删除指定位置的元素，用`pop(i)`，其中 i 是索引位置：

```python
>>> classmates.pop(1)
'Jack'
>>> classmates
['Michael', 'Bob', 'Tracy']
```

要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：

```python
>>> classmates[1] = 'Sarah'
>>> classmates
['Michael', 'Sarah', 'Tracy']
```

这里再说回之前的「字符串」，字符串虽然和数组是两个不同的数据类型，但是它其实就是「字符」构成的数组，字符串也可以用索引：

```python
>>> c = '"hello"'
>>> c[0]
'"'
>>> c[-1]
'"'
>>> c[1]
'h'
```

---

Tuple 和 list 几乎一样，也是一个有序列表。定义方式也非常类似：

```python
numbers_list = [2, 4, 7, 3, 9, 10]
tuple_list = (2, 4, 7, 3, 9, 10)
```

重点在于，**当你定义一个 tuple 时，在定义的时候，tuple 的元素就必须被确定下来**，换句话说，tuple 无法被更改，只能查看 tuple 中的元素！

这样做的好处在于，tuple 不可变，所以代码更安全。如果可能，能用 tuple 代替 list 就尽量用 tuple。

---

数组根据索引，按照 0, 1, 2, . . . 的顺序存储值，而字典则以键值对（key-value）的形式存储数据。字典就像《新华字典》那样，将单词和它的含义对应着存储起来。

```python
>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
>>> d['Michael']
95
```

把数据放入 dict 的方法，除了初始化时指定外，还可以通过 key 放入：

```python
>>> d['Adam'] = 67
>>> d['Adam']
67
```

由于一个 key 只能对应一个 value，所以，多次对一个 key 放入 value，后面的值会把前面的值冲掉：

```python
>>> d['Jack'] = 90
>>> d['Jack']
90
>>> d['Jack'] = 88
>>> d['Jack']
88
>>> d['Thomas'] # 如果key不存在，dict就会报错：
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'Thomas'
```

#### 2.3. 条件判断

非常好理解，因为条件判断基本就是在说人话。比如，输入用户年龄，根据年龄打印不同的内容，在 Python 程序中，用 if 语句实现：

```python
age = 20
if age >= 18:
    print('your age is', age)
    print('adult')
```

只需要注意一下 `≥` 在 python 中用 `>=` 替代，就行了。还有，**不要少写了冒号！！**

```python
age = 3
if age >= 18:
    print('adult')
elif age >= 6:
    print('teenager')
else:
    print('kid')
```

- else: 字面意思，不满足`age >= 18`也不满足`age >= 6`
- elif: else if 的简称，也是字面意思。

所以 if 语句的完整形式就是：

```python
if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
    <执行4>
```

其中 elif, else 都是可有可无的，就是说删了 elif 这个条件判断分支，代码是不会报错的。

#### 2.4. Python 的严格缩进机制

![a6bb70bd67da42925e1e3796d1ddc980.png](/image_resources/a6bb70bd67da42925e1e3796d1ddc980.png)

![30ff48140581660ee3dcfeeef185e646.png](/image_resources/30ff48140581660ee3dcfeeef185e646.png)

这两段代码有什么不同？？为什么上面会报错？？

#### 2.5. 循环

要计算 1+2+3，我们可以直接写表达式：

```python
>>> 1 + 2 + 3
6
```

但是，要计算 1+2+3+...+10000，直接写表达式就不可能了。为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。

```python
names = ['Michael', 'Bob', 'Tracy']
for name in names:
    print(name)
```

执行这段代码，会依次打印 names 的每一个元素：

```text
Michael
Bob
Tracy
```

所以`for x in ...`循环就是把每个元素代入变量 x，然后执行后面的语句。

`range(101)`是使用 python 提供的`range()`函数，生成 0-100 的整数序列（0-100 嘛，101 个数）

```python
sum = 0
# 生成涵盖0～100的数组
for x in range(101):
    sum = sum + x
print(sum)
# 5050
```

除了 for 循环外，还有 while 循环：

```python
sum = 0
n = 99
while n > 0:
    sum = sum + n
    n = n - 2
print(sum)
```

这里`while n > 0:`表示，只要满足 n>0, 循环就会一直进行下去，直到发现 n<=0 了，退出循环，打印 sum 的值。

### 3. 函数

#### 3.0 函数简介

上面其实已经出现了很多函数了，但都是 python 内置的

- len(): 用于计算数组的长度
- range(): 生成整数序列
- print(): 把东西打印到控制台
- type(): 来查看变量的数据类型

`list.pop()`不是删除 list 末尾的一个元素嘛？那 pop 算函数吗？

`pop()`单独用会报错啊！只有`pop()`前面加一个点，变成`numbers.pop()`才能正常运行。这是因为 pop 是「数组」这个数据类型提供的一个「方法」，虽然长得像函数，定义也很像，但是得做出区分。

#### 3.1 使用函数

试试看直接调用 python 的内置函数之一，abs 函数：

```python
>>> abs(100)
100
>>> abs(-20)
20
>>> abs(12.34)
12.34
```

调用函数的时候，如果传入的参数数量不对，会报 TypeError 的错误，并且 Python 会明确地告诉你：abs()有且仅有 1 个参数，但给出了两个：

```python
>>> abs(1, 2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: abs() takes exactly one argument (2 given)
```

如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报 TypeError 的错误，并且给出错误信息：str 是错误的参数类型：

```python
>>> abs('a')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: bad operand type for abs(): 'str'
```

而 max 函数`max()`可以接收任意多个参数，并返回最大的那个：

```python
>>> max(1, 2)
2
>>> max(2, 3, 1, -5)
3
```

#### 3.2 定义函数

我们以自定义一个求绝对值的 my_abs 函数为例：

```python
def my_abs(x):
    if x >= 0:
        return x
    else:
        return -x
```

很好理解，因为 def 就是 define（定义）的意思。就是这里有个 return 需要理解一下，众所周知，**一个函数不能有两个返回值**，高中数学教的对吧？所以，一个函数只要执行了一个 return，就停下来了，不可能执行其他 return 了。

```
>>> my_abs(-9)
9
```

如果函数有多个参数也是一样的：

```python
def calculate_distance(x1, y1, x2, y2):
    """
    计算两点之间的距离

    参数:
    x1 (float): 第一个点的 x 坐标
    y1 (float): 第一个点的 y 坐标
    x2 (float): 第二个点的 x 坐标
    y2 (float): 第二个点的 y 坐标

    返回值:
    float: 两点之间的距离
    """
    # 计算 x 轴上的差值
    x_diff = x2 - x1
    # 计算 y 轴上的差值
    y_diff = y2 - y1
    # 计算两点之间的直线距离
    distance = (x_diff ** 2 + y_diff ** 2) ** 0.5
    return distance
```

使用方法：

```python
# 调用函数计算两点之间的距离
distance = calculate_distance(1, 2, 4, 6)

# 打印结果： 5.0
print("两点之间的距离为:", distance)
```

### 4. 使用模块

Python 本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。

#### 4.0 用 math 模块

math 模块可以看作一个数学工具箱，里面什么函数都有。比如，计算 log 的，开根的，三角函数等等。举个例子，比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：

```python
# 导入math包，import就是
import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
```

`import math`语句表示导入 math 包，并允许后续代码引用 math 包里的 sin、cos 等函数。

发现什么问题没有？之前不是说**函数不可能有两个返回值**吗？这是什么？`return nx, ny` 这不是两个吗？

其实这只是 python 为了写起来更方便，制造的一种假象。move 函数仍然返回的是单一值！我们调用它看看：

```python
>>> r = move(100, 100, 60, math.pi / 6)
>>> print(r)
(151.96152422706632, 70.0)
```

原来返回值是一个 tuple！在 tuple 里面一个个取值太麻烦了，于是 python 提供了一个可以让写代码舒适度提高很多的语法：

```python
>>> x, y = move(100, 100, 60, math.pi / 6)
>>> print(x, y)
151.96152422706632 70.0
```

---

从下面开始，python 才开始变得有意思起来。

#### 4.1 使用 turtle 模块

turtle 就是鼎鼎有名的海龟作图模块。

```
# 导入turtle包
import turtle

# 设置笔刷宽度:
turtle.width(4)

# 前进:
turtle.forward(200)
# 右转90度:
turtle.right(90)

# 设置笔刷颜色:
turtle.pencolor('red')
turtle.forward(100)
turtle.right(90)

turtle.pencolor('green')
turtle.forward(200)
turtle.right(90)

turtle.pencolor('blue')
turtle.forward(100)
turtle.right(90)

# turtle.调用done()使得窗口等待被关闭，否则将立刻关闭窗口:
turtle.done()
```

![bbf1c1b1ae4f8114d83a31d7a45c78a4.png](/image_resources/bbf1c1b1ae4f8114d83a31d7a45c78a4.png)

turtle 包本身只是一个绘图库，但是配合 Python 代码，比如循环、函数等就可以绘制各种复杂的图形：

```python
import turtle

# 一个在(x, y)坐标画出一个五角星的函数
def drawStar(x, y):
    # 抬起画笔，不留轨迹
    turtle.penup()
    # 去给定坐标
    turtle.goto(x, y)
    # 落下画笔，开始绘画
    turtle.pendown()
    # 设置箭头朝向（0代表向正右方）
    turtle.setheading(0)
    for i in range(5):
        turtle.forward(40)
        # 向右旋转144度
        turtle.right(144)

for x in range(0, 250, 50):
    drawStar(x, 0)

turtle.done()
```

![ffed385a89147f863e6e266315b6e884.png](/image_resources/ffed385a89147f863e6e266315b6e884.png)

#### 4.2 安装第三方模块

所有的第三方模块都会在[PyPI - the Python Package Index](https://pypi.org/)上注册，只要找到对应的模块名字，即可用 pip 安装。

如果你已经正确地安装了 python，那 pip 应该也是装上了的，如果命令行报错，可以试着重新安装 python，把安装 pip 勾选一下。

比如爬虫必备的 requests 库。没有安装的时候，运行 import 语句会报错。

```python
>>> import requests
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ModuleNotFoundError: No module named 'requests'
>>>
```

但是当你打开命令提示符（终端），输入这行命令以后，如果没有报错就是安装完成了。

```bash
~$ pip install requests
...
Successfully installed certifi-2023.7.22 charset-normalizer-3.3.1 idna-3.4 requests-2.31.0 urllib3-2.0.7
```

**注意！！如果出现红色的字，或者没有看到 Successfully installed requests，说明安装失败了，此时 90%以上的可能是“网络问题”，pypi 服务器有点不太稳定。因此我们可以用 pypi 镜像站代替。**

镜像站指的是把 pypi 所有东西都放到了国内的服务器上，可以更加稳定快速的下载。常见镜像站有：

- 清华：https://pypi.tuna.tsinghua.edu.cn/simple/
- 阿里云：http://mirrors.aliyun.com/pypi/simple/
- 中国科技大学：https://pypi.mirrors.ustc.edu.cn/simple/
- 华中科技大学：http://pypi.hustunique.com/simple/
- 上海交通大学：https://mirror.sjtu.edu.cn/pypi/web/simple/
- 豆瓣：http://pypi.douban.com/simple/

那如何让 pip 不从 pypi 服务器下载，改用我们提供的镜像网址呢？很简单，用 -i 参数指定一下就行了

```bash
~$ pip install -i https://pypi.tuna.tsinghua.edu.cn/simple requests
```

安装成功后再次 import 就能看到结果了：

```python
>>> import requests
>>> 
```

。。。好吧没有结果。要知道，没有消息才是最好的消息（）

<!-- #### 4.3. 练手：安装并运行pygame

想要用python写游戏的同学，推荐pygame，以及最详细的pygame教程

同样的，安装pygame只用一行：

```bash
~$ pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pygame
``` -->

## Part2. Git 入门

### 0. git是什么？

Git是目前世界上最先进的分布式版本控制系统（没有之一）。

#### 0.1 什么是版本控制系统？

如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：

想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：

![e041caf8e31f18112e1177df8c3d3fe1.png](/image_resources/e041caf8e31f18112e1177df8c3d3fe1.png)

看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。

你在想，要是有个软件，能自动帮我记录每次文件的改动，如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？

「版本控制系统」便应运而生。

#### 0.2 什么叫分布式？

可以说现在有两种版本控制系统：**集中式**和**分布式**。

先说集中式版本控制系统，SVN是其代表。版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，里面存放着某本书的所有版本（从第一版到最新版）如果我向图书馆借书，它通常只会给我最新版的，我如果想要改之前版本的，还需要再向图书馆借。所以，当使用SVN工作时，要保证与服务器的连接畅通。（不严谨一点，其实可以理解为腾讯共享文档，每次更新内容，都需要联网）

![445af03b6348f3bb2b667d0817d8e25d.png](/image_resources/445af03b6348f3bb2b667d0817d8e25d.png)

分布式版本控制系统，GIT是最好用的。分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都存有这本书的所有版本的信息，你改动这本书的时候也不需要联网了，因为所有版本就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。

![87b1d310413a87ab5f48cf0bac458acf.png](/image_resources/87b1d310413a87ab5f48cf0bac458acf.png)

那GitHub是什么鬼？不是说git不用中央服务器吗？

GitHub确实不是中央服务器，它是用来“交换”大家的修改，你其实用QQ也是一样的，无非就是文件传输呗。当然后面GitHub壮大起来，成为了世界上最大的开源社区，这是后事了，待会会讲。

总之，集中式和分布式的区别是：你的本地是否有完整的版本库历史！假设SVN服务器没了，那你丢掉了所有历史信息，因为你的本地只有当前版本以及部分历史信息。而假设GitHub服务器没了，你不会丢掉任何git历史信息，因为你的本地有完整的版本库信息。你可以把本地的git库重新上传到另外的git服务商。

#### 0.3 Git的诞生

这是一个很有趣的故事。

> 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。
> 
> Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？
> 
> 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！
> 
> 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。
> 
> 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。
> 
> 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。
> 
> Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的：
> 
> Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。
> 
> Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。
> 
> 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。

#### Markdown语法

有一个问题不知道大家发现没，word和pdf都是二进制文件，刚才也讲了，git对文本文件做了优化也就是我们常用的文件格式，

## Part3. GitHub 使用完全教程

